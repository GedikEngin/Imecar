regex:
https://www.postgresql.org/docs/current/functions-matching.html

# pay attention to joins, relations

SELECT <col> FROM <table> # basic column

SELECT <column1>, <col2>..., FROM <table name> # returns the columns specified from table

ORDER BY <col> ASC/DESC,  <col2> ASC/DESC, <col3> ASC/DESC # orders info in ascending/descending order, you can also sort by columns that you dont select but its better to have it

SELECT DISTINCT <col> FROM <table> #returns the different entries that arent duplicate in table
#or for legability/ease of use
SELECT DISTINCT(<col>) FROM <table>

SELECT COUNT(<col>) FROM <table> #returns the number of items of column in table

SELECT COUNT(DISTINCT(<col>)) FROM <table> # returns number of unique items in column in table

SELECT WHERE # has comparison operators, = equal > graeter than < less than >= greater than or equal to <= less than or equal to <> or != not equal to

SELECT <col1> <col2>... FROM <table> WHERE <col you want to apply condition to> {condition} # returns selected columns where condition is applied to column from table
ex: SELECT title, rental_rate FROM film WHERE rental_rate <= 3

SELECT <col1> <col2>... FROM <table> WHERE <col you want to apply condition to> {condition} and {condition2} and {con3}.... # you can chain conditions

LIMIT # goes at the end of the command, as its the final command and cuts out data that surpasses the amount requested
SELECT <column1> FROM <table> LIMIT 10 # will give us the first 10 rows
SELECT * FROM payment ORDER BY payment_date DESC LIMIT 10 # gives the most recent 10 transactions within context

SELECT <column1> FROM <table> WHERE <col> BETWEEN val1 AND val2 # it works for dates also in format 'YYYY-MM-DD', keep in mind end date goes upp to 00:00 time only
SELECT <column1> FROM <table> WHERE <col> NOT BETWEEN val1 AND val2 #i.e. if you want info between 12 nov and 14 nov, you need to put 15 nov as end date

SELECT <col> FROM <table> WHERE <col> IN <val you are looking to match> # returns items from col where they match the values provided from in
SELECT <col> FROM <table> WHERE <col> NOT IN <val you are looking to match> # does the same but returns items that arent in val

SELECT <col> FROM <table> LIKE '%gmail.com' # returns all strings with gmail.com at the end, % matches any sequence of characters

SELECT <col> FROM <table> LIKE 'Mission Impossible _' # means it will only be the _ being replaced, _ matches one character

you can mix and match wildcards:
WHERE name LIKE '_her%' # name will be one opening character, followed by her, followed by any number of characters
you can also use ilike if you want the string like to be case insensitive
or you can sandwhich it as '%er%' to return names with er at any point in their name
you can use it in tandem with not to look for data that doesnt include the like

data types:
boolean: true or false
character: char, varchar, text
numeric: integet, float
temporal: date, time. timestamp, interval
uuid: universally unique identifiers
array
json
hstore key value pair
special types: network addresses, geometric data

constraints:
2 types, column & table constraints
column constraints:
not null: ensures column isnt null
unique: ensures all values in column are different
primary key: uniquely identifies each row/record in db
foreign key: constrains data based on columns in other tables
check: ensures all values in a column satify certain conditions
exclusion: if any 2 rows are compared on the specified column or expression using the specified operator, not all of these comparisons will return true

table constraints:
check(condition): to check a condition when inserting or updating data references : to constrain the value stored in the column that must exists in a column in another table
unique(column_list): forces the values stored in the columns listed inside the brackets to be unique
primary key(column_list): allows you to define the primary key that consists of multiple columns

example table creation & linking:
CREATE TABLE account(
	user_id SERIAL PRIMARY KEY,
	username VARCHAR(50) UNIQUE NOT NULL,
	password VARCHAR(50) NOT NULL,
	email VARCHAR(250) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
	last_login TIMESTAMP
)

CREATE TABLE job(
	job_id SERIAL PRIMARY KEY,
	job_name VARCHAR(200) UNIQUE NOT NULL
)

CREATE TABLE account_job(
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
)

