regex:
https://www.postgresql.org/docs/current/functions-matching.html

joins:
https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/

# pay attention to joins, relations

SELECT <col> FROM <table> # basic column

SELECT <column1>, <col2>..., FROM <table name> # returns the columns specified from table

ORDER BY <col> ASC/DESC,  <col2> ASC/DESC, <col3> ASC/DESC # orders info in ascending/descending order, you can also sort by columns that you dont select but its better to have it

SELECT DISTINCT <col> FROM <table> #returns the different entries that arent duplicate in table
#or for legability/ease of use
SELECT DISTINCT(<col>) FROM <table>

SELECT COUNT(<col>) FROM <table> #returns the number of items of column in table

SELECT COUNT(DISTINCT(<col>)) FROM <table> # returns number of unique items in column in table

SELECT WHERE # has comparison operators, = equal > graeter than < less than >= greater than or equal to <= less than or equal to <> or != not equal to

SELECT <col1> <col2>... FROM <table> WHERE <col you want to apply condition to> {condition} # returns selected columns where condition is applied to column from table
ex: SELECT title, rental_rate FROM film WHERE rental_rate <= 3

SELECT <col1> <col2>... FROM <table> WHERE <col you want to apply condition to> {condition} and {condition2} and {con3}.... # you can chain conditions

LIMIT # goes at the end of the command, as its the final command and cuts out data that surpasses the amount requested
SELECT <column1> FROM <table> LIMIT 10 # will give us the first 10 rows
SELECT * FROM payment ORDER BY payment_date DESC LIMIT 10 # gives the most recent 10 transactions within context

SELECT <column1> FROM <table> WHERE <col> BETWEEN val1 AND val2 # it works for dates also in format 'YYYY-MM-DD', keep in mind end date goes upp to 00:00 time only
SELECT <column1> FROM <table> WHERE <col> NOT BETWEEN val1 AND val2 #i.e. if you want info between 12 nov and 14 nov, you need to put 15 nov as end date

SELECT <col> FROM <table> WHERE <col> IN <val you are looking to match> # returns items from col where they match the values provided from in
SELECT <col> FROM <table> WHERE <col> NOT IN <val you are looking to match> # does the same but returns items that arent in val

SELECT <col> FROM <table> LIKE '%gmail.com' # returns all strings with gmail.com at the end, % matches any sequence of characters

SELECT <col> FROM <table> LIKE 'Mission Impossible _' # means it will only be the _ being replaced, _ matches one character

you can mix and match wildcards:
WHERE name LIKE '_her%' # name will be one opening character, followed by her, followed by any number of characters
you can also use ilike if you want the string like to be case insensitive
or you can sandwhich it as '%er%' to return names with er at any point in their name
you can use it in tandem with not to look for data that doesnt include the like

data types:
boolean: true or false
character: char, varchar, text
numeric: integet, float
temporal: date, time. timestamp, interval
uuid: universally unique identifiers
array
json
hstore key value pair
special types: network addresses, geometric data

constraints:
2 types, column & table constraints
column constraints:
not null: ensures column isnt null
unique: ensures all values in column are different
primary key: uniquely identifies each row/record in db
foreign key: constrains data based on columns in other tables
check: ensures all values in a column satify certain conditions
exclusion: if any 2 rows are compared on the specified column or expression using the specified operator, not all of these comparisons will return true

table constraints:
check(condition): to check a condition when inserting or updating data references : to constrain the value stored in the column that must exists in a column in another table
unique(column_list): forces the values stored in the columns listed inside the brackets to be unique
primary key(column_list): allows you to define the primary key that consists of multiple columns

example table creation & linking:
CREATE TABLE account(
	user_id SERIAL PRIMARY KEY,
	username VARCHAR(50) UNIQUE NOT NULL,
	password VARCHAR(50) NOT NULL,
	email VARCHAR(250) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
	last_login TIMESTAMP
)

CREATE TABLE job(
	job_id SERIAL PRIMARY KEY,
	job_name VARCHAR(200) UNIQUE NOT NULL
)

CREATE TABLE account_job(
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
)

inserting data:
INSERT INTO account(username, password, email, created_on) VALUES ('jose', 'password', 'jose@mail.com', current_timestamp)
INSERT INTO job(job_name) VALUES ('President')

connection insert:
INSERT INTO account_job(user_id, job_id, hire_date) VALUES (1, 1, CURRENT_TIMESTAMP)

to update:
UPDATE account SET last_login = CURRENT_TIMESTAMP;

update join:
UPDATE account_job SET hire_date = account.created_on FROM account WHERE account_job.user_id = account.user_id
# updates hire_date in account_job to created_on inside account table, and where the id's match up from user_id in account_job and account

update using return command:
UPDATE account SET last_login = CURRENT_TIMESTAMP RETURNING email, created_on, last_login
# updates account last_login to current_timestamp and returns columns specified <email, created_on, last_login> 

DELETE FROM <table> # deletes the entire contents of table
DELETE FROM <table> WHERE <col> = <condition> # deletes based on condition
DELETE FROM job WHERE <job_name> = <'cowboy'> # deletes cowboy from job table

deleting based on presence in other tables:
DELETE FROM <tableA> USING <tableB> WHERE tableA.id = tableB.id

Alter is used to add drop or renaming columns. change data types and setting constants, check constraints and renaming table
ALTER TABLE <table_name> # the base command

ALTER TABLE <table_name> RENAME TO <new_name>

ADD COLUMN new_col TYPE # to add new column
DROP COLUMN <col_name> # drops the column

ALTER TABLE <table_name> # the base command, followed by:
ALTER COLUMN <col_name> # to execute an action from below
	SET DEFAULT value #implement this to have a default value to act as an initial entry to column
	DROP DEFAULT # removes default value
	SET NOT NULL # prevents column from being a blank entry
	DROP NOT NULL # drops not null constraints
	ADD CONSTRAINT <constraint_name> # add a constraint using the name like check constraint

ALTER TABLE <table_name>
DROP COLUMN IF EXISTS <col_name>
#drops the column if it exists, think of it as error catching

check constraint:
create table employees(
	emp_id serial primary key,
	first_name varchar(50) not null,
	last_name varchar(50) not null,
	birthdate date check (birthdate > '1900-01-01'), # checks birthdate is greaater than (after) 1900-01-01
	hire_date date check (hire_date > birthdate), # checks hire date is post birthdate
	salary integer check (salary > 0) # ensures salary cannot be 0
)


aggregate function:
takes multiple inputs and returns one output:
ROUND(<column>, <digits to round to>) # rounds to the number of specified digits
AVG(<column>) # returns average value, gives float
COUNT(<column>) # returns the number of values
MAX(<column>) # returns maximum value
MIN(<column>) # returns minimum value
SUM(<column>) # returns the sum of all values

only happens when using select or have in

group by is suitable for grouping similar types, i.e. cabins in planes, first class, business, economy, etc.
GROUP BY needs to appear right after a FROM or WHERE statement

items from SELECT need to come up in GROUP BY:
SELECT company, division, SUM(sales) FROM finance_table GROUP BY company, division # groups the sum of total sales for each company and their divisions

SELECT customer_id FROM payment GROUP BY customer_id # gets all the customer ids, almost a distinct function in this case
SELECT customer_id, SUM(amount) FROM payment GROUP BY customer_id ORDER BY SUM(amount) # checks the most spending customers

SELECT staff_id, COUNT(amount) FROM payment GROUP BY staff_id # returns the staff id and corresponding number of sales as it GROUPs the count of ''payments' made by them
SELECT staff_id, COUNT(*) FROM payment GROUP BY staff_id # returns the staff id and corresponding number of rows as it GROUPs the count of ''payments' made by them

SELECT rating, AVG(replacement_cost) FROM film GROUP BY rating # returns average replacement cost for each movie rating

select customer_id, sum(amount) from payment GROUP BY customer_id ORDER BY SUM(amount) DESC LIMIT 5 # returms the top spending 5 customers, and the amount they spent as well as their id

SELECT customer_id, SUM(amount) FROM payment WHERE customer_id > 100 GROUP BY customer_ID ORDER BY customer_id ASC # ordering template

having clause allows you to filter post aggregation, so after group by

SELECT customer_id, SUM(amount) FROM payment GROUP BY customer_id HAVING SUM(amount) > 100 # groups the spendings from customer id to one, and then returns ones which have a total sum spent over 100

select store_id, count(customer_id) from customer group by store_id having count(customer_id) > 300 # returns store ids that have over 300 customers associated with that store

